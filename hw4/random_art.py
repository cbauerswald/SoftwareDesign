
# -*- coding: utf-8 -*-
"""
Created on Tue Feb 11 11:34:57 2014

@author: pruvolo
"""

# you do not have to use these particular modules, but they may help
from random import randint
import math
import Image

def build_random_function(min_depth, max_depth):
    # your doc string goes here
    """
    This function recursively generates a function from subfunctions.
    inputs: 
        min_depth:integer that is minimum recursion depth
        max_depth: integer that is maximum recursion depth
        min_depth must be less than or equal to max_depth
    output: nested list of function, argument pairs that can code for a function
    """
    new_min =1
    all_components = [['x',0], ['y',0],['sin_pi',1], ['cos_pi',1],['prod',2], ['atan',1], ['pow',2]]
    if (max_depth ==0):
        new_max = max_depth
        new_min = min_depth
        components = all_components[0:2]
        
    elif (min_depth==0 and max_depth!=0):
        components = all_components
        new_min = 0;
        new_max = max_depth-1;
    else:
        components = all_components[2:]
        new_max = max_depth -1
        new_min = min_depth -1

    func = components[randint(0,len(components)-1)]
    if func[1]==0:
        return [func[0]]
    elif func[1]==1:
        arg = build_random_function(new_min, new_max)
        return [func[0], arg]
    elif func[1]==2: 
        arg1 = build_random_function(new_min, new_max)
        arg2 = build_random_function(new_min, new_max)
        return [func[0], arg1, arg2]
    

def evaluate_random_function(f, x, y):
    # your doc string goes here
    """
    This function turns the randomly generated function and a values for x and y and outputs the out of of F(x,y)
    Inputs:
        f - function generated by build_random_function/ function in the format of ["elementary function name here", argument 1 (optional), argument 2 (optional)]
        x- the number value of x s.t. x:[-1,1]
        y- the number value of y s.t. y:[-1,1]
    Outputs:
        the output of function f, given inputs x and y
    """
    if f[0]=='x':
        output = x 
    elif f[0]=='y':
        output =y
    if f[0]=='sin_pi':
        output = math.sin(math.pi*evaluate_random_function(f[1], x,y))
    elif f[0]=='cos_pi':
        output = math.cos(math.pi*evaluate_random_function(f[1],x,y))
    elif f[0]=='prod':
        output = evaluate_random_function(f[1],x,y)*evaluate_random_function(f[2],x,y)
    elif f[0]=='atan':
        output = math.atan(evaluate_random_function(f[1],x,y))
    elif f[0]=='pow':
        output = abs(evaluate_random_function(f[1],x,y))**evaluate_random_function(f[2],x,y)
    
    return output
    
    
    
    
    
    
    

def remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):
    """ Maps the input value that is in the interval [input_interval_start, input_interval_end]
        to the output interval [output_interval_start, output_interval_end].  The mapping
        is an affine one (i.e. output = input*c + b).
    
        TODO: please fill out the rest of this docstring
    """
    ratio = float(val - input_interval_start)/(input_interval_end - input_interval_start)
    
    remapped_val = ratio * (output_interval_end-output_interval_start) +output_interval_start
    
    return remapped_val
    
    # your code goes here


if __name__ == "__main__":
    im = Image.new("RGB",(350,350))
    r_func = build_random_function(3,5)
    g_func = build_random_function(3,5)
    b_func = build_random_function(3,5)
    for x in range(0,350):
        for y in range(0,350):
            mapped_x = remap_interval(x,0,349,-1,1)
            mapped_y = remap_interval(y,0,349,-1,1)
            r = int(remap_interval(evaluate_random_function(r_func, mapped_x, mapped_y),-1,1,0,255))
            g = int(remap_interval(evaluate_random_function(g_func, mapped_x, mapped_y),-1,1,0,255))
            b = int(remap_interval(evaluate_random_function(b_func, mapped_x, mapped_y),-1,1,0,255))
            im.putpixel((x,y),(r,g,b))
    
    im.save('pic7.jpg')


























    